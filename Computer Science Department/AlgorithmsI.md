###Algorithms I

[Algorithms: Design and Analysis, Part 1](https://www.coursera.org/course/algo)
Tim Roughgarden
Stanford University

####About the Course

In this course you will learn several fundamental principles of algorithm design. You'll learn the divide-and-conquer design paradigm, with applications to fast sorting, searching, and multiplication. You'll learn several blazingly fast primitives for computing on graphs, such as how to compute connectivity information and shortest paths. Finally, we'll study how allowing the computer to "flip coins" can lead to elegant and practical algorithms and data structures. Learn the answers to questions such as: How do data structures like heaps, hash tables, bloom filters, and balanced search trees actually work, anyway? How come QuickSort runs so fast? What can graph algorithms tell us about the structure of the Web and social networks? Did my 3rd-grade teacher explain only a suboptimal algorithm for multiplying two numbers?

####Course Format

* Coursera MOOC
* 6 weeks of study
* 5-7 hours a week
* Video lecture with integrated quiz
* Programming assignments
* Final exam

####Course Syllabus

* big-O notation
* Randomized algorithms
* Graph primitive
* Dijkstra's shortest-path algorithm
* Data-Structures
* Binary search trees

####Prerequisites

* Programming (C, Java, Python)
* Proofs
* *Data structures*

####Searls Commentary
Compared to the [Data Structures course]() which also cover algorithms, these courses are considered upper-level and stress analysis over implementation, even though they include hefty programming assignments. The instructor has an unintimidating, indeed rather breezy style, and the syllabus is not as rigidly organized as many other treatments of the topic area, but in the end it is effective. The material is largely presented in handwritten form, as on a whiteboard, and thankfully it is legible if not elegant. The programming assignments can be done in the language of your choice since they are graded by whether you correctly return some numerical answer to a problem so compute-intensive as to mandate the "correct" implementation (unless you happen to have access to a supercomputer and are able to brute force it).
