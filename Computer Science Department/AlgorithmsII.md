###Algorithms II

[Algorithms: Design and Analysis, Part 2](https://www.coursera.org/course/algo2)
Tim Roughgarden
Stanford University

####About the Course

In this course you will learn several fundamental principles of advanced algorithm design. You'll learn the greedy algorithm design paradigm, with applications to computing good network backbones (i.e., spanning trees) and good codes for data compression. You'll learn the tricky yet widely applicable dynamic programming algorithm design paradigm, with applications to routing in the Internet and sequencing genome fragments.  You’ll learn what NP-completeness and the famous “P vs. NP” problem mean for the algorithm designer.  Finally, we’ll study several strategies for dealing with hard (i.e., NP-complete problems), including the design and analysis of heuristics.  Learn how shortest-path algorithms from the 1950s (i.e., pre-ARPANET!) govern the way that your Internet traffic gets routed today; why efficient algorithms are fundamental to modern genomics; and how to make a million bucks in prize money by “just” solving a math problem!

####Course Format

* Coursera MOOC
* 6 weeks of study
* 6-10 hours a week
* Video lecture with integrated quiz
* Programming assignments
* Final exam

####Course Syllabus

* Greedy algorithm design paradigm
* The dynamic programming design paradigm
* Intractable problems and what to do about them.

####Prerequisites

* Algorithms I
* Programming (C, Java, Python)
* Proofs
* *Data structures*

####Searls Commentary
Compared to the [Data Structures course]() which also cover algorithms, these courses are considered upper-level and stress analysis over implementation, even though they include hefty programming assignments. The instructor has an unintimidating, indeed rather breezy style, and the syllabus is not as rigidly organized as many other treatments of the topic area, but in the end it is effective. The material is largely presented in handwritten form, as on a whiteboard, and thankfully it is legible if not elegant. The programming assignments can be done in the language of your choice since they are graded by whether you correctly return some numerical answer to a problem so compute-intensive as to mandate the "correct" implementation (unless you happen to have access to a supercomputer and are able to brute force it).
